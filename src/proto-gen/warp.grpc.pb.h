// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: warp.proto
#ifndef GRPC_warp_2eproto__INCLUDED
#define GRPC_warp_2eproto__INCLUDED

#include "warp.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace proto {

// ************ Important! ***************
//
// If you change anything here, you *must* run 'generate-protobuf' to update the
// generated stub files.
//
// Never change the existing members and member values of messages, only add new ones.
//
class Warp final {
 public:
  static constexpr char const* service_full_name() {
    return "proto.Warp";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Sender methods
    // api v1 duplex method (ping style)
    virtual ::grpc::Status CheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName& request, ::proto::HaveDuplex* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>> AsyncCheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>>(AsyncCheckDuplexConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>> PrepareAsyncCheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>>(PrepareAsyncCheckDuplexConnectionRaw(context, request, cq));
    }
    // api v2 duplex method (block/future)
    virtual ::grpc::Status WaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName& request, ::proto::HaveDuplex* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>> AsyncWaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>>(AsyncWaitingForDuplexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>> PrepareAsyncWaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>>(PrepareAsyncWaitingForDuplexRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName& request, ::proto::RemoteMachineInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::RemoteMachineInfo>> AsyncGetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::RemoteMachineInfo>>(AsyncGetRemoteMachineInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::RemoteMachineInfo>> PrepareAsyncGetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::RemoteMachineInfo>>(PrepareAsyncGetRemoteMachineInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::proto::RemoteMachineAvatar>> GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::proto::RemoteMachineAvatar>>(GetRemoteMachineAvatarRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::proto::RemoteMachineAvatar>> AsyncGetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::proto::RemoteMachineAvatar>>(AsyncGetRemoteMachineAvatarRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::proto::RemoteMachineAvatar>> PrepareAsyncGetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::proto::RemoteMachineAvatar>>(PrepareAsyncGetRemoteMachineAvatarRaw(context, request, cq));
    }
    virtual ::grpc::Status ProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::proto::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> AsyncProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(AsyncProcessTransferOpRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> PrepareAsyncProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(PrepareAsyncProcessTransferOpRequestRaw(context, request, cq));
    }
    virtual ::grpc::Status PauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::proto::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> AsyncPauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(AsyncPauseTransferOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> PrepareAsyncPauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(PrepareAsyncPauseTransferOpRaw(context, request, cq));
    }
    // Receiver methods
    std::unique_ptr< ::grpc::ClientReaderInterface< ::proto::FileChunk>> StartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::proto::FileChunk>>(StartTransferRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::proto::FileChunk>> AsyncStartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::proto::FileChunk>>(AsyncStartTransferRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::proto::FileChunk>> PrepareAsyncStartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::proto::FileChunk>>(PrepareAsyncStartTransferRaw(context, request, cq));
    }
    // Both
    virtual ::grpc::Status CancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::proto::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> AsyncCancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(AsyncCancelTransferOpRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> PrepareAsyncCancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(PrepareAsyncCancelTransferOpRequestRaw(context, request, cq));
    }
    virtual ::grpc::Status StopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::proto::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> AsyncStopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(AsyncStopTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> PrepareAsyncStopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(PrepareAsyncStopTransferRaw(context, request, cq));
    }
    virtual ::grpc::Status Ping(::grpc::ClientContext* context, const ::proto::LookupName& request, ::proto::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> AsyncPing(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>> PrepareAsyncPing(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>>(PrepareAsyncPingRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Sender methods
      // api v1 duplex method (ping style)
      virtual void CheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // api v2 duplex method (block/future)
      virtual void WaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::RemoteMachineInfo* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::RemoteMachineInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::RemoteMachineInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName* request, ::grpc::ClientReadReactor< ::proto::RemoteMachineAvatar>* reactor) = 0;
      #else
      virtual void GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName* request, ::grpc::experimental::ClientReadReactor< ::proto::RemoteMachineAvatar>* reactor) = 0;
      #endif
      virtual void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void PauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Receiver methods
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::grpc::ClientReadReactor< ::proto::FileChunk>* reactor) = 0;
      #else
      virtual void StartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::grpc::experimental::ClientReadReactor< ::proto::FileChunk>* reactor) = 0;
      #endif
      // Both
      virtual void CancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void StopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Ping(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Ping(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Ping(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>* AsyncCheckDuplexConnectionRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>* PrepareAsyncCheckDuplexConnectionRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>* AsyncWaitingForDuplexRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::HaveDuplex>* PrepareAsyncWaitingForDuplexRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::RemoteMachineInfo>* AsyncGetRemoteMachineInfoRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::RemoteMachineInfo>* PrepareAsyncGetRemoteMachineInfoRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::proto::RemoteMachineAvatar>* GetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::proto::LookupName& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::proto::RemoteMachineAvatar>* AsyncGetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::proto::RemoteMachineAvatar>* PrepareAsyncGetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* AsyncProcessTransferOpRequestRaw(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* PrepareAsyncProcessTransferOpRequestRaw(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* AsyncPauseTransferOpRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* PrepareAsyncPauseTransferOpRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::proto::FileChunk>* StartTransferRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::proto::FileChunk>* AsyncStartTransferRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::proto::FileChunk>* PrepareAsyncStartTransferRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* AsyncCancelTransferOpRequestRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* PrepareAsyncCancelTransferOpRequestRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* AsyncStopTransferRaw(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* PrepareAsyncStopTransferRaw(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* AsyncPingRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::VoidType>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName& request, ::proto::HaveDuplex* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>> AsyncCheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>>(AsyncCheckDuplexConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>> PrepareAsyncCheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>>(PrepareAsyncCheckDuplexConnectionRaw(context, request, cq));
    }
    ::grpc::Status WaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName& request, ::proto::HaveDuplex* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>> AsyncWaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>>(AsyncWaitingForDuplexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>> PrepareAsyncWaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>>(PrepareAsyncWaitingForDuplexRaw(context, request, cq));
    }
    ::grpc::Status GetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName& request, ::proto::RemoteMachineInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::RemoteMachineInfo>> AsyncGetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::RemoteMachineInfo>>(AsyncGetRemoteMachineInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::RemoteMachineInfo>> PrepareAsyncGetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::RemoteMachineInfo>>(PrepareAsyncGetRemoteMachineInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::proto::RemoteMachineAvatar>> GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::proto::RemoteMachineAvatar>>(GetRemoteMachineAvatarRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::proto::RemoteMachineAvatar>> AsyncGetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::proto::RemoteMachineAvatar>>(AsyncGetRemoteMachineAvatarRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::proto::RemoteMachineAvatar>> PrepareAsyncGetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::proto::RemoteMachineAvatar>>(PrepareAsyncGetRemoteMachineAvatarRaw(context, request, cq));
    }
    ::grpc::Status ProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::proto::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> AsyncProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(AsyncProcessTransferOpRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> PrepareAsyncProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(PrepareAsyncProcessTransferOpRequestRaw(context, request, cq));
    }
    ::grpc::Status PauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::proto::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> AsyncPauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(AsyncPauseTransferOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> PrepareAsyncPauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(PrepareAsyncPauseTransferOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::proto::FileChunk>> StartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::proto::FileChunk>>(StartTransferRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::proto::FileChunk>> AsyncStartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::proto::FileChunk>>(AsyncStartTransferRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::proto::FileChunk>> PrepareAsyncStartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::proto::FileChunk>>(PrepareAsyncStartTransferRaw(context, request, cq));
    }
    ::grpc::Status CancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::proto::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> AsyncCancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(AsyncCancelTransferOpRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> PrepareAsyncCancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(PrepareAsyncCancelTransferOpRequestRaw(context, request, cq));
    }
    ::grpc::Status StopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::proto::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> AsyncStopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(AsyncStopTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> PrepareAsyncStopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(PrepareAsyncStopTransferRaw(context, request, cq));
    }
    ::grpc::Status Ping(::grpc::ClientContext* context, const ::proto::LookupName& request, ::proto::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> AsyncPing(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>> PrepareAsyncPing(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::VoidType>>(PrepareAsyncPingRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CheckDuplexConnection(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WaitingForDuplex(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::RemoteMachineInfo* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::RemoteMachineInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::RemoteMachineInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName* request, ::grpc::ClientReadReactor< ::proto::RemoteMachineAvatar>* reactor) override;
      #else
      void GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::proto::LookupName* request, ::grpc::experimental::ClientReadReactor< ::proto::RemoteMachineAvatar>* reactor) override;
      #endif
      void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::proto::TransferOpRequest* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PauseTransferOp(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::grpc::ClientReadReactor< ::proto::FileChunk>* reactor) override;
      #else
      void StartTransfer(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::grpc::experimental::ClientReadReactor< ::proto::FileChunk>* reactor) override;
      #endif
      void CancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CancelTransferOpRequest(::grpc::ClientContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void StopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StopTransfer(::grpc::ClientContext* context, const ::proto::StopInfo* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Ping(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::VoidType* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Ping(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Ping(::grpc::ClientContext* context, const ::proto::LookupName* request, ::proto::VoidType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>* AsyncCheckDuplexConnectionRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>* PrepareAsyncCheckDuplexConnectionRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>* AsyncWaitingForDuplexRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::HaveDuplex>* PrepareAsyncWaitingForDuplexRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::RemoteMachineInfo>* AsyncGetRemoteMachineInfoRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::RemoteMachineInfo>* PrepareAsyncGetRemoteMachineInfoRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::proto::RemoteMachineAvatar>* GetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::proto::LookupName& request) override;
    ::grpc::ClientAsyncReader< ::proto::RemoteMachineAvatar>* AsyncGetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::proto::RemoteMachineAvatar>* PrepareAsyncGetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* AsyncProcessTransferOpRequestRaw(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* PrepareAsyncProcessTransferOpRequestRaw(::grpc::ClientContext* context, const ::proto::TransferOpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* AsyncPauseTransferOpRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* PrepareAsyncPauseTransferOpRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::proto::FileChunk>* StartTransferRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request) override;
    ::grpc::ClientAsyncReader< ::proto::FileChunk>* AsyncStartTransferRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::proto::FileChunk>* PrepareAsyncStartTransferRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* AsyncCancelTransferOpRequestRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* PrepareAsyncCancelTransferOpRequestRaw(::grpc::ClientContext* context, const ::proto::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* AsyncStopTransferRaw(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* PrepareAsyncStopTransferRaw(::grpc::ClientContext* context, const ::proto::StopInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* AsyncPingRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::VoidType>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::proto::LookupName& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CheckDuplexConnection_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitingForDuplex_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRemoteMachineInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRemoteMachineAvatar_;
    const ::grpc::internal::RpcMethod rpcmethod_ProcessTransferOpRequest_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseTransferOp_;
    const ::grpc::internal::RpcMethod rpcmethod_StartTransfer_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelTransferOpRequest_;
    const ::grpc::internal::RpcMethod rpcmethod_StopTransfer_;
    const ::grpc::internal::RpcMethod rpcmethod_Ping_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Sender methods
    // api v1 duplex method (ping style)
    virtual ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response);
    // api v2 duplex method (block/future)
    virtual ::grpc::Status WaitingForDuplex(::grpc::ServerContext* context, const ::proto::LookupName* request, ::proto::HaveDuplex* response);
    virtual ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* context, const ::proto::LookupName* request, ::proto::RemoteMachineInfo* response);
    virtual ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* context, const ::proto::LookupName* request, ::grpc::ServerWriter< ::proto::RemoteMachineAvatar>* writer);
    virtual ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* context, const ::proto::TransferOpRequest* request, ::proto::VoidType* response);
    virtual ::grpc::Status PauseTransferOp(::grpc::ServerContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response);
    // Receiver methods
    virtual ::grpc::Status StartTransfer(::grpc::ServerContext* context, const ::proto::OpInfo* request, ::grpc::ServerWriter< ::proto::FileChunk>* writer);
    // Both
    virtual ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* context, const ::proto::OpInfo* request, ::proto::VoidType* response);
    virtual ::grpc::Status StopTransfer(::grpc::ServerContext* context, const ::proto::StopInfo* request, ::proto::VoidType* response);
    virtual ::grpc::Status Ping(::grpc::ServerContext* context, const ::proto::LookupName* request, ::proto::VoidType* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckDuplexConnection(::grpc::ServerContext* context, ::proto::LookupName* request, ::grpc::ServerAsyncResponseWriter< ::proto::HaveDuplex>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitingForDuplex(::grpc::ServerContext* context, ::proto::LookupName* request, ::grpc::ServerAsyncResponseWriter< ::proto::HaveDuplex>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRemoteMachineInfo(::grpc::ServerContext* context, ::proto::LookupName* request, ::grpc::ServerAsyncResponseWriter< ::proto::RemoteMachineInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::grpc::ServerWriter< ::proto::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRemoteMachineAvatar(::grpc::ServerContext* context, ::proto::LookupName* request, ::grpc::ServerAsyncWriter< ::proto::RemoteMachineAvatar>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::TransferOpRequest* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProcessTransferOpRequest(::grpc::ServerContext* context, ::proto::TransferOpRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseTransferOp(::grpc::ServerContext* context, ::proto::OpInfo* request, ::grpc::ServerAsyncResponseWriter< ::proto::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartTransfer() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::grpc::ServerWriter< ::proto::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTransfer(::grpc::ServerContext* context, ::proto::OpInfo* request, ::grpc::ServerAsyncWriter< ::proto::FileChunk>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelTransferOpRequest(::grpc::ServerContext* context, ::proto::OpInfo* request, ::grpc::ServerAsyncResponseWriter< ::proto::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopTransfer() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::proto::StopInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopTransfer(::grpc::ServerContext* context, ::proto::StopInfo* request, ::grpc::ServerAsyncResponseWriter< ::proto::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ping() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::proto::LookupName* request, ::grpc::ServerAsyncResponseWriter< ::proto::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CheckDuplexConnection<WithAsyncMethod_WaitingForDuplex<WithAsyncMethod_GetRemoteMachineInfo<WithAsyncMethod_GetRemoteMachineAvatar<WithAsyncMethod_ProcessTransferOpRequest<WithAsyncMethod_PauseTransferOp<WithAsyncMethod_StartTransfer<WithAsyncMethod_CancelTransferOpRequest<WithAsyncMethod_StopTransfer<WithAsyncMethod_Ping<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CheckDuplexConnection() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::LookupName, ::proto::HaveDuplex>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::LookupName* request, ::proto::HaveDuplex* response) { return this->CheckDuplexConnection(context, request, response); }));}
    void SetMessageAllocatorFor_CheckDuplexConnection(
        ::grpc::experimental::MessageAllocator< ::proto::LookupName, ::proto::HaveDuplex>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::LookupName, ::proto::HaveDuplex>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CheckDuplexConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CheckDuplexConnection(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WaitingForDuplex() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::LookupName, ::proto::HaveDuplex>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::LookupName* request, ::proto::HaveDuplex* response) { return this->WaitingForDuplex(context, request, response); }));}
    void SetMessageAllocatorFor_WaitingForDuplex(
        ::grpc::experimental::MessageAllocator< ::proto::LookupName, ::proto::HaveDuplex>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::LookupName, ::proto::HaveDuplex>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WaitingForDuplex(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WaitingForDuplex(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRemoteMachineInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::LookupName, ::proto::RemoteMachineInfo>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::LookupName* request, ::proto::RemoteMachineInfo* response) { return this->GetRemoteMachineInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetRemoteMachineInfo(
        ::grpc::experimental::MessageAllocator< ::proto::LookupName, ::proto::RemoteMachineInfo>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::LookupName, ::proto::RemoteMachineInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRemoteMachineInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::RemoteMachineInfo* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRemoteMachineInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::RemoteMachineInfo* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRemoteMachineAvatar() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::proto::LookupName, ::proto::RemoteMachineAvatar>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::LookupName* request) { return this->GetRemoteMachineAvatar(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::grpc::ServerWriter< ::proto::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::proto::RemoteMachineAvatar>* GetRemoteMachineAvatar(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::proto::RemoteMachineAvatar>* GetRemoteMachineAvatar(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ProcessTransferOpRequest() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::TransferOpRequest, ::proto::VoidType>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::TransferOpRequest* request, ::proto::VoidType* response) { return this->ProcessTransferOpRequest(context, request, response); }));}
    void SetMessageAllocatorFor_ProcessTransferOpRequest(
        ::grpc::experimental::MessageAllocator< ::proto::TransferOpRequest, ::proto::VoidType>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::TransferOpRequest, ::proto::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::TransferOpRequest* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ProcessTransferOpRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::TransferOpRequest* /*request*/, ::proto::VoidType* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ProcessTransferOpRequest(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::TransferOpRequest* /*request*/, ::proto::VoidType* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PauseTransferOp() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::OpInfo, ::proto::VoidType>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::OpInfo* request, ::proto::VoidType* response) { return this->PauseTransferOp(context, request, response); }));}
    void SetMessageAllocatorFor_PauseTransferOp(
        ::grpc::experimental::MessageAllocator< ::proto::OpInfo, ::proto::VoidType>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::OpInfo, ::proto::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PauseTransferOp(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PauseTransferOp(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StartTransfer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::proto::OpInfo, ::proto::FileChunk>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::OpInfo* request) { return this->StartTransfer(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::grpc::ServerWriter< ::proto::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::proto::FileChunk>* StartTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::OpInfo* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::proto::FileChunk>* StartTransfer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::OpInfo* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CancelTransferOpRequest() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::OpInfo, ::proto::VoidType>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::OpInfo* request, ::proto::VoidType* response) { return this->CancelTransferOpRequest(context, request, response); }));}
    void SetMessageAllocatorFor_CancelTransferOpRequest(
        ::grpc::experimental::MessageAllocator< ::proto::OpInfo, ::proto::VoidType>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::OpInfo, ::proto::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelTransferOpRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelTransferOpRequest(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StopTransfer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::StopInfo, ::proto::VoidType>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::StopInfo* request, ::proto::VoidType* response) { return this->StopTransfer(context, request, response); }));}
    void SetMessageAllocatorFor_StopTransfer(
        ::grpc::experimental::MessageAllocator< ::proto::StopInfo, ::proto::VoidType>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::StopInfo, ::proto::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::proto::StopInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StopTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::StopInfo* /*request*/, ::proto::VoidType* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StopTransfer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::StopInfo* /*request*/, ::proto::VoidType* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Ping() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::LookupName, ::proto::VoidType>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::LookupName* request, ::proto::VoidType* response) { return this->Ping(context, request, response); }));}
    void SetMessageAllocatorFor_Ping(
        ::grpc::experimental::MessageAllocator< ::proto::LookupName, ::proto::VoidType>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::LookupName, ::proto::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::VoidType* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ping(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::VoidType* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_CheckDuplexConnection<ExperimentalWithCallbackMethod_WaitingForDuplex<ExperimentalWithCallbackMethod_GetRemoteMachineInfo<ExperimentalWithCallbackMethod_GetRemoteMachineAvatar<ExperimentalWithCallbackMethod_ProcessTransferOpRequest<ExperimentalWithCallbackMethod_PauseTransferOp<ExperimentalWithCallbackMethod_StartTransfer<ExperimentalWithCallbackMethod_CancelTransferOpRequest<ExperimentalWithCallbackMethod_StopTransfer<ExperimentalWithCallbackMethod_Ping<Service > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_CheckDuplexConnection<ExperimentalWithCallbackMethod_WaitingForDuplex<ExperimentalWithCallbackMethod_GetRemoteMachineInfo<ExperimentalWithCallbackMethod_GetRemoteMachineAvatar<ExperimentalWithCallbackMethod_ProcessTransferOpRequest<ExperimentalWithCallbackMethod_PauseTransferOp<ExperimentalWithCallbackMethod_StartTransfer<ExperimentalWithCallbackMethod_CancelTransferOpRequest<ExperimentalWithCallbackMethod_StopTransfer<ExperimentalWithCallbackMethod_Ping<Service > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::grpc::ServerWriter< ::proto::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::TransferOpRequest* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartTransfer() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::grpc::ServerWriter< ::proto::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopTransfer() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::proto::StopInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ping() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckDuplexConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitingForDuplex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRemoteMachineInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::grpc::ServerWriter< ::proto::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRemoteMachineAvatar(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::TransferOpRequest* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProcessTransferOpRequest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseTransferOp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartTransfer() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::grpc::ServerWriter< ::proto::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTransfer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelTransferOpRequest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopTransfer() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::proto::StopInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopTransfer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ping() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CheckDuplexConnection() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckDuplexConnection(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CheckDuplexConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CheckDuplexConnection(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WaitingForDuplex() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WaitingForDuplex(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WaitingForDuplex(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WaitingForDuplex(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRemoteMachineInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRemoteMachineInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRemoteMachineInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRemoteMachineInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRemoteMachineAvatar() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GetRemoteMachineAvatar(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::grpc::ServerWriter< ::proto::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetRemoteMachineAvatar(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GetRemoteMachineAvatar(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ProcessTransferOpRequest() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ProcessTransferOpRequest(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::TransferOpRequest* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ProcessTransferOpRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ProcessTransferOpRequest(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PauseTransferOp() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseTransferOp(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PauseTransferOp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PauseTransferOp(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StartTransfer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->StartTransfer(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::grpc::ServerWriter< ::proto::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StartTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* StartTransfer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CancelTransferOpRequest() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelTransferOpRequest(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelTransferOpRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelTransferOpRequest(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StopTransfer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopTransfer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::proto::StopInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StopTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StopTransfer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Ping() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ping(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ping(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::LookupName, ::proto::HaveDuplex>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::LookupName, ::proto::HaveDuplex>* streamer) {
                       return this->StreamedCheckDuplexConnection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckDuplexConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::LookupName,::proto::HaveDuplex>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::LookupName, ::proto::HaveDuplex>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::LookupName, ::proto::HaveDuplex>* streamer) {
                       return this->StreamedWaitingForDuplex(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitingForDuplex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::LookupName,::proto::HaveDuplex>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::LookupName, ::proto::RemoteMachineInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::LookupName, ::proto::RemoteMachineInfo>* streamer) {
                       return this->StreamedGetRemoteMachineInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRemoteMachineInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::LookupName,::proto::RemoteMachineInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::TransferOpRequest, ::proto::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::TransferOpRequest, ::proto::VoidType>* streamer) {
                       return this->StreamedProcessTransferOpRequest(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::TransferOpRequest* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProcessTransferOpRequest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::TransferOpRequest,::proto::VoidType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::OpInfo, ::proto::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::OpInfo, ::proto::VoidType>* streamer) {
                       return this->StreamedPauseTransferOp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseTransferOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::OpInfo,::proto::VoidType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::OpInfo, ::proto::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::OpInfo, ::proto::VoidType>* streamer) {
                       return this->StreamedCancelTransferOpRequest(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelTransferOpRequest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::OpInfo,::proto::VoidType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopTransfer() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::StopInfo, ::proto::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::StopInfo, ::proto::VoidType>* streamer) {
                       return this->StreamedStopTransfer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::proto::StopInfo* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopTransfer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::StopInfo,::proto::VoidType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ping() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::LookupName, ::proto::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::LookupName, ::proto::VoidType>* streamer) {
                       return this->StreamedPing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::proto::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::LookupName,::proto::VoidType>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CheckDuplexConnection<WithStreamedUnaryMethod_WaitingForDuplex<WithStreamedUnaryMethod_GetRemoteMachineInfo<WithStreamedUnaryMethod_ProcessTransferOpRequest<WithStreamedUnaryMethod_PauseTransferOp<WithStreamedUnaryMethod_CancelTransferOpRequest<WithStreamedUnaryMethod_StopTransfer<WithStreamedUnaryMethod_Ping<Service > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::proto::LookupName, ::proto::RemoteMachineAvatar>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::proto::LookupName, ::proto::RemoteMachineAvatar>* streamer) {
                       return this->StreamedGetRemoteMachineAvatar(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::proto::LookupName* /*request*/, ::grpc::ServerWriter< ::proto::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetRemoteMachineAvatar(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::proto::LookupName,::proto::RemoteMachineAvatar>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StartTransfer() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::proto::OpInfo, ::proto::FileChunk>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::proto::OpInfo, ::proto::FileChunk>* streamer) {
                       return this->StreamedStartTransfer(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::proto::OpInfo* /*request*/, ::grpc::ServerWriter< ::proto::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStartTransfer(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::proto::OpInfo,::proto::FileChunk>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetRemoteMachineAvatar<WithSplitStreamingMethod_StartTransfer<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_CheckDuplexConnection<WithStreamedUnaryMethod_WaitingForDuplex<WithStreamedUnaryMethod_GetRemoteMachineInfo<WithSplitStreamingMethod_GetRemoteMachineAvatar<WithStreamedUnaryMethod_ProcessTransferOpRequest<WithStreamedUnaryMethod_PauseTransferOp<WithSplitStreamingMethod_StartTransfer<WithStreamedUnaryMethod_CancelTransferOpRequest<WithStreamedUnaryMethod_StopTransfer<WithStreamedUnaryMethod_Ping<Service > > > > > > > > > > StreamedService;
};

class WarpRegistration final {
 public:
  static constexpr char const* service_full_name() {
    return "proto.WarpRegistration";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status RequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::proto::RegResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::RegResponse>> AsyncRequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::RegResponse>>(AsyncRequestCertificateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::RegResponse>> PrepareAsyncRequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::proto::RegResponse>>(PrepareAsyncRequestCertificateRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void RequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest* request, ::proto::RegResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest* request, ::proto::RegResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest* request, ::proto::RegResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::RegResponse>* AsyncRequestCertificateRaw(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::proto::RegResponse>* PrepareAsyncRequestCertificateRaw(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status RequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::proto::RegResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::RegResponse>> AsyncRequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::RegResponse>>(AsyncRequestCertificateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::RegResponse>> PrepareAsyncRequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::proto::RegResponse>>(PrepareAsyncRequestCertificateRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void RequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest* request, ::proto::RegResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest* request, ::proto::RegResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RequestCertificate(::grpc::ClientContext* context, const ::proto::RegRequest* request, ::proto::RegResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::proto::RegResponse>* AsyncRequestCertificateRaw(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::proto::RegResponse>* PrepareAsyncRequestCertificateRaw(::grpc::ClientContext* context, const ::proto::RegRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_RequestCertificate_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status RequestCertificate(::grpc::ServerContext* context, const ::proto::RegRequest* request, ::proto::RegResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::proto::RegRequest* /*request*/, ::proto::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestCertificate(::grpc::ServerContext* context, ::proto::RegRequest* request, ::grpc::ServerAsyncResponseWriter< ::proto::RegResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_RequestCertificate<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RequestCertificate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::proto::RegRequest, ::proto::RegResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::proto::RegRequest* request, ::proto::RegResponse* response) { return this->RequestCertificate(context, request, response); }));}
    void SetMessageAllocatorFor_RequestCertificate(
        ::grpc::experimental::MessageAllocator< ::proto::RegRequest, ::proto::RegResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::proto::RegRequest, ::proto::RegResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::proto::RegRequest* /*request*/, ::proto::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RequestCertificate(
      ::grpc::CallbackServerContext* /*context*/, const ::proto::RegRequest* /*request*/, ::proto::RegResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RequestCertificate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::proto::RegRequest* /*request*/, ::proto::RegResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_RequestCertificate<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_RequestCertificate<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::proto::RegRequest* /*request*/, ::proto::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::proto::RegRequest* /*request*/, ::proto::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestCertificate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RequestCertificate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RequestCertificate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::proto::RegRequest* /*request*/, ::proto::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RequestCertificate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RequestCertificate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::proto::RegRequest, ::proto::RegResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::proto::RegRequest, ::proto::RegResponse>* streamer) {
                       return this->StreamedRequestCertificate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::proto::RegRequest* /*request*/, ::proto::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestCertificate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::proto::RegRequest,::proto::RegResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_RequestCertificate<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_RequestCertificate<Service > StreamedService;
};

}  // namespace proto


#endif  // GRPC_warp_2eproto__INCLUDED
