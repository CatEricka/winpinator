// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: warp.proto
#ifndef GRPC_warp_2eproto__INCLUDED
#define GRPC_warp_2eproto__INCLUDED

#include "warp.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

// ************ Important! ***************
//
// If you change anything here, you *must* run 'generate-protobuf' to update the
// generated stub files.
//
// Never change the existing members and member values of messages, only add new ones.
//
class Warp final {
 public:
  static constexpr char const* service_full_name() {
    return "Warp";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Sender methods
    // api v1 duplex method (ping style)
    virtual ::grpc::Status CheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName& request, ::HaveDuplex* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>> AsyncCheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>>(AsyncCheckDuplexConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>> PrepareAsyncCheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>>(PrepareAsyncCheckDuplexConnectionRaw(context, request, cq));
    }
    // api v2 duplex method (block/future)
    virtual ::grpc::Status WaitingForDuplex(::grpc::ClientContext* context, const ::LookupName& request, ::HaveDuplex* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>> AsyncWaitingForDuplex(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>>(AsyncWaitingForDuplexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>> PrepareAsyncWaitingForDuplex(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>>(PrepareAsyncWaitingForDuplexRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName& request, ::RemoteMachineInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteMachineInfo>> AsyncGetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteMachineInfo>>(AsyncGetRemoteMachineInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteMachineInfo>> PrepareAsyncGetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteMachineInfo>>(PrepareAsyncGetRemoteMachineInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::RemoteMachineAvatar>> GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::LookupName& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::RemoteMachineAvatar>>(GetRemoteMachineAvatarRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::RemoteMachineAvatar>> AsyncGetRemoteMachineAvatar(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::RemoteMachineAvatar>>(AsyncGetRemoteMachineAvatarRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::RemoteMachineAvatar>> PrepareAsyncGetRemoteMachineAvatar(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::RemoteMachineAvatar>>(PrepareAsyncGetRemoteMachineAvatarRaw(context, request, cq));
    }
    virtual ::grpc::Status ProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> AsyncProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(AsyncProcessTransferOpRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> PrepareAsyncProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(PrepareAsyncProcessTransferOpRequestRaw(context, request, cq));
    }
    virtual ::grpc::Status PauseTransferOp(::grpc::ClientContext* context, const ::OpInfo& request, ::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> AsyncPauseTransferOp(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(AsyncPauseTransferOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> PrepareAsyncPauseTransferOp(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(PrepareAsyncPauseTransferOpRaw(context, request, cq));
    }
    // Receiver methods
    std::unique_ptr< ::grpc::ClientReaderInterface< ::FileChunk>> StartTransfer(::grpc::ClientContext* context, const ::OpInfo& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::FileChunk>>(StartTransferRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::FileChunk>> AsyncStartTransfer(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::FileChunk>>(AsyncStartTransferRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::FileChunk>> PrepareAsyncStartTransfer(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::FileChunk>>(PrepareAsyncStartTransferRaw(context, request, cq));
    }
    // Both
    virtual ::grpc::Status CancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo& request, ::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> AsyncCancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(AsyncCancelTransferOpRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> PrepareAsyncCancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(PrepareAsyncCancelTransferOpRequestRaw(context, request, cq));
    }
    virtual ::grpc::Status StopTransfer(::grpc::ClientContext* context, const ::StopInfo& request, ::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> AsyncStopTransfer(::grpc::ClientContext* context, const ::StopInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(AsyncStopTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> PrepareAsyncStopTransfer(::grpc::ClientContext* context, const ::StopInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(PrepareAsyncStopTransferRaw(context, request, cq));
    }
    virtual ::grpc::Status Ping(::grpc::ClientContext* context, const ::LookupName& request, ::VoidType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> AsyncPing(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>> PrepareAsyncPing(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>>(PrepareAsyncPingRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Sender methods
      // api v1 duplex method (ping style)
      virtual void CheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName* request, ::HaveDuplex* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName* request, ::HaveDuplex* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // api v2 duplex method (block/future)
      virtual void WaitingForDuplex(::grpc::ClientContext* context, const ::LookupName* request, ::HaveDuplex* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WaitingForDuplex(::grpc::ClientContext* context, const ::LookupName* request, ::HaveDuplex* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName* request, ::RemoteMachineInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName* request, ::RemoteMachineInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::LookupName* request, ::grpc::ClientReadReactor< ::RemoteMachineAvatar>* reactor) = 0;
      virtual void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest* request, ::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PauseTransferOp(::grpc::ClientContext* context, const ::OpInfo* request, ::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PauseTransferOp(::grpc::ClientContext* context, const ::OpInfo* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Receiver methods
      virtual void StartTransfer(::grpc::ClientContext* context, const ::OpInfo* request, ::grpc::ClientReadReactor< ::FileChunk>* reactor) = 0;
      // Both
      virtual void CancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo* request, ::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopTransfer(::grpc::ClientContext* context, const ::StopInfo* request, ::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopTransfer(::grpc::ClientContext* context, const ::StopInfo* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Ping(::grpc::ClientContext* context, const ::LookupName* request, ::VoidType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Ping(::grpc::ClientContext* context, const ::LookupName* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>* AsyncCheckDuplexConnectionRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>* PrepareAsyncCheckDuplexConnectionRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>* AsyncWaitingForDuplexRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::HaveDuplex>* PrepareAsyncWaitingForDuplexRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteMachineInfo>* AsyncGetRemoteMachineInfoRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteMachineInfo>* PrepareAsyncGetRemoteMachineInfoRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::RemoteMachineAvatar>* GetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::LookupName& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::RemoteMachineAvatar>* AsyncGetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::RemoteMachineAvatar>* PrepareAsyncGetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* AsyncProcessTransferOpRequestRaw(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* PrepareAsyncProcessTransferOpRequestRaw(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* AsyncPauseTransferOpRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* PrepareAsyncPauseTransferOpRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::FileChunk>* StartTransferRaw(::grpc::ClientContext* context, const ::OpInfo& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::FileChunk>* AsyncStartTransferRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::FileChunk>* PrepareAsyncStartTransferRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* AsyncCancelTransferOpRequestRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* PrepareAsyncCancelTransferOpRequestRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* AsyncStopTransferRaw(::grpc::ClientContext* context, const ::StopInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* PrepareAsyncStopTransferRaw(::grpc::ClientContext* context, const ::StopInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* AsyncPingRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::VoidType>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status CheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName& request, ::HaveDuplex* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HaveDuplex>> AsyncCheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HaveDuplex>>(AsyncCheckDuplexConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HaveDuplex>> PrepareAsyncCheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HaveDuplex>>(PrepareAsyncCheckDuplexConnectionRaw(context, request, cq));
    }
    ::grpc::Status WaitingForDuplex(::grpc::ClientContext* context, const ::LookupName& request, ::HaveDuplex* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HaveDuplex>> AsyncWaitingForDuplex(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HaveDuplex>>(AsyncWaitingForDuplexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HaveDuplex>> PrepareAsyncWaitingForDuplex(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HaveDuplex>>(PrepareAsyncWaitingForDuplexRaw(context, request, cq));
    }
    ::grpc::Status GetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName& request, ::RemoteMachineInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteMachineInfo>> AsyncGetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteMachineInfo>>(AsyncGetRemoteMachineInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteMachineInfo>> PrepareAsyncGetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteMachineInfo>>(PrepareAsyncGetRemoteMachineInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::RemoteMachineAvatar>> GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::LookupName& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::RemoteMachineAvatar>>(GetRemoteMachineAvatarRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::RemoteMachineAvatar>> AsyncGetRemoteMachineAvatar(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::RemoteMachineAvatar>>(AsyncGetRemoteMachineAvatarRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::RemoteMachineAvatar>> PrepareAsyncGetRemoteMachineAvatar(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::RemoteMachineAvatar>>(PrepareAsyncGetRemoteMachineAvatarRaw(context, request, cq));
    }
    ::grpc::Status ProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> AsyncProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(AsyncProcessTransferOpRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> PrepareAsyncProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(PrepareAsyncProcessTransferOpRequestRaw(context, request, cq));
    }
    ::grpc::Status PauseTransferOp(::grpc::ClientContext* context, const ::OpInfo& request, ::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> AsyncPauseTransferOp(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(AsyncPauseTransferOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> PrepareAsyncPauseTransferOp(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(PrepareAsyncPauseTransferOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::FileChunk>> StartTransfer(::grpc::ClientContext* context, const ::OpInfo& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::FileChunk>>(StartTransferRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::FileChunk>> AsyncStartTransfer(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::FileChunk>>(AsyncStartTransferRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::FileChunk>> PrepareAsyncStartTransfer(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::FileChunk>>(PrepareAsyncStartTransferRaw(context, request, cq));
    }
    ::grpc::Status CancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo& request, ::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> AsyncCancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(AsyncCancelTransferOpRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> PrepareAsyncCancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(PrepareAsyncCancelTransferOpRequestRaw(context, request, cq));
    }
    ::grpc::Status StopTransfer(::grpc::ClientContext* context, const ::StopInfo& request, ::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> AsyncStopTransfer(::grpc::ClientContext* context, const ::StopInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(AsyncStopTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> PrepareAsyncStopTransfer(::grpc::ClientContext* context, const ::StopInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(PrepareAsyncStopTransferRaw(context, request, cq));
    }
    ::grpc::Status Ping(::grpc::ClientContext* context, const ::LookupName& request, ::VoidType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> AsyncPing(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>> PrepareAsyncPing(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::VoidType>>(PrepareAsyncPingRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void CheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName* request, ::HaveDuplex* response, std::function<void(::grpc::Status)>) override;
      void CheckDuplexConnection(::grpc::ClientContext* context, const ::LookupName* request, ::HaveDuplex* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WaitingForDuplex(::grpc::ClientContext* context, const ::LookupName* request, ::HaveDuplex* response, std::function<void(::grpc::Status)>) override;
      void WaitingForDuplex(::grpc::ClientContext* context, const ::LookupName* request, ::HaveDuplex* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName* request, ::RemoteMachineInfo* response, std::function<void(::grpc::Status)>) override;
      void GetRemoteMachineInfo(::grpc::ClientContext* context, const ::LookupName* request, ::RemoteMachineInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRemoteMachineAvatar(::grpc::ClientContext* context, const ::LookupName* request, ::grpc::ClientReadReactor< ::RemoteMachineAvatar>* reactor) override;
      void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest* request, ::VoidType* response, std::function<void(::grpc::Status)>) override;
      void ProcessTransferOpRequest(::grpc::ClientContext* context, const ::TransferOpRequest* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PauseTransferOp(::grpc::ClientContext* context, const ::OpInfo* request, ::VoidType* response, std::function<void(::grpc::Status)>) override;
      void PauseTransferOp(::grpc::ClientContext* context, const ::OpInfo* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartTransfer(::grpc::ClientContext* context, const ::OpInfo* request, ::grpc::ClientReadReactor< ::FileChunk>* reactor) override;
      void CancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo* request, ::VoidType* response, std::function<void(::grpc::Status)>) override;
      void CancelTransferOpRequest(::grpc::ClientContext* context, const ::OpInfo* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopTransfer(::grpc::ClientContext* context, const ::StopInfo* request, ::VoidType* response, std::function<void(::grpc::Status)>) override;
      void StopTransfer(::grpc::ClientContext* context, const ::StopInfo* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Ping(::grpc::ClientContext* context, const ::LookupName* request, ::VoidType* response, std::function<void(::grpc::Status)>) override;
      void Ping(::grpc::ClientContext* context, const ::LookupName* request, ::VoidType* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::HaveDuplex>* AsyncCheckDuplexConnectionRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::HaveDuplex>* PrepareAsyncCheckDuplexConnectionRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::HaveDuplex>* AsyncWaitingForDuplexRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::HaveDuplex>* PrepareAsyncWaitingForDuplexRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteMachineInfo>* AsyncGetRemoteMachineInfoRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteMachineInfo>* PrepareAsyncGetRemoteMachineInfoRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::RemoteMachineAvatar>* GetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::LookupName& request) override;
    ::grpc::ClientAsyncReader< ::RemoteMachineAvatar>* AsyncGetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::RemoteMachineAvatar>* PrepareAsyncGetRemoteMachineAvatarRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* AsyncProcessTransferOpRequestRaw(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* PrepareAsyncProcessTransferOpRequestRaw(::grpc::ClientContext* context, const ::TransferOpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* AsyncPauseTransferOpRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* PrepareAsyncPauseTransferOpRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::FileChunk>* StartTransferRaw(::grpc::ClientContext* context, const ::OpInfo& request) override;
    ::grpc::ClientAsyncReader< ::FileChunk>* AsyncStartTransferRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::FileChunk>* PrepareAsyncStartTransferRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* AsyncCancelTransferOpRequestRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* PrepareAsyncCancelTransferOpRequestRaw(::grpc::ClientContext* context, const ::OpInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* AsyncStopTransferRaw(::grpc::ClientContext* context, const ::StopInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* PrepareAsyncStopTransferRaw(::grpc::ClientContext* context, const ::StopInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* AsyncPingRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::VoidType>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::LookupName& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CheckDuplexConnection_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitingForDuplex_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRemoteMachineInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRemoteMachineAvatar_;
    const ::grpc::internal::RpcMethod rpcmethod_ProcessTransferOpRequest_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseTransferOp_;
    const ::grpc::internal::RpcMethod rpcmethod_StartTransfer_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelTransferOpRequest_;
    const ::grpc::internal::RpcMethod rpcmethod_StopTransfer_;
    const ::grpc::internal::RpcMethod rpcmethod_Ping_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Sender methods
    // api v1 duplex method (ping style)
    virtual ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* context, const ::LookupName* request, ::HaveDuplex* response);
    // api v2 duplex method (block/future)
    virtual ::grpc::Status WaitingForDuplex(::grpc::ServerContext* context, const ::LookupName* request, ::HaveDuplex* response);
    virtual ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* context, const ::LookupName* request, ::RemoteMachineInfo* response);
    virtual ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* context, const ::LookupName* request, ::grpc::ServerWriter< ::RemoteMachineAvatar>* writer);
    virtual ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* context, const ::TransferOpRequest* request, ::VoidType* response);
    virtual ::grpc::Status PauseTransferOp(::grpc::ServerContext* context, const ::OpInfo* request, ::VoidType* response);
    // Receiver methods
    virtual ::grpc::Status StartTransfer(::grpc::ServerContext* context, const ::OpInfo* request, ::grpc::ServerWriter< ::FileChunk>* writer);
    // Both
    virtual ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* context, const ::OpInfo* request, ::VoidType* response);
    virtual ::grpc::Status StopTransfer(::grpc::ServerContext* context, const ::StopInfo* request, ::VoidType* response);
    virtual ::grpc::Status Ping(::grpc::ServerContext* context, const ::LookupName* request, ::VoidType* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckDuplexConnection(::grpc::ServerContext* context, ::LookupName* request, ::grpc::ServerAsyncResponseWriter< ::HaveDuplex>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitingForDuplex(::grpc::ServerContext* context, ::LookupName* request, ::grpc::ServerAsyncResponseWriter< ::HaveDuplex>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRemoteMachineInfo(::grpc::ServerContext* context, ::LookupName* request, ::grpc::ServerAsyncResponseWriter< ::RemoteMachineInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::grpc::ServerWriter< ::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRemoteMachineAvatar(::grpc::ServerContext* context, ::LookupName* request, ::grpc::ServerAsyncWriter< ::RemoteMachineAvatar>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::TransferOpRequest* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProcessTransferOpRequest(::grpc::ServerContext* context, ::TransferOpRequest* request, ::grpc::ServerAsyncResponseWriter< ::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseTransferOp(::grpc::ServerContext* context, ::OpInfo* request, ::grpc::ServerAsyncResponseWriter< ::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartTransfer() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::grpc::ServerWriter< ::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTransfer(::grpc::ServerContext* context, ::OpInfo* request, ::grpc::ServerAsyncWriter< ::FileChunk>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelTransferOpRequest(::grpc::ServerContext* context, ::OpInfo* request, ::grpc::ServerAsyncResponseWriter< ::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopTransfer() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::StopInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopTransfer(::grpc::ServerContext* context, ::StopInfo* request, ::grpc::ServerAsyncResponseWriter< ::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ping() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::LookupName* request, ::grpc::ServerAsyncResponseWriter< ::VoidType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CheckDuplexConnection<WithAsyncMethod_WaitingForDuplex<WithAsyncMethod_GetRemoteMachineInfo<WithAsyncMethod_GetRemoteMachineAvatar<WithAsyncMethod_ProcessTransferOpRequest<WithAsyncMethod_PauseTransferOp<WithAsyncMethod_StartTransfer<WithAsyncMethod_CancelTransferOpRequest<WithAsyncMethod_StopTransfer<WithAsyncMethod_Ping<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::LookupName, ::HaveDuplex>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::LookupName* request, ::HaveDuplex* response) { return this->CheckDuplexConnection(context, request, response); }));}
    void SetMessageAllocatorFor_CheckDuplexConnection(
        ::grpc::MessageAllocator< ::LookupName, ::HaveDuplex>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::LookupName, ::HaveDuplex>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckDuplexConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::LookupName, ::HaveDuplex>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::LookupName* request, ::HaveDuplex* response) { return this->WaitingForDuplex(context, request, response); }));}
    void SetMessageAllocatorFor_WaitingForDuplex(
        ::grpc::MessageAllocator< ::LookupName, ::HaveDuplex>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::LookupName, ::HaveDuplex>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitingForDuplex(
      ::grpc::CallbackServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::LookupName, ::RemoteMachineInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::LookupName* request, ::RemoteMachineInfo* response) { return this->GetRemoteMachineInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetRemoteMachineInfo(
        ::grpc::MessageAllocator< ::LookupName, ::RemoteMachineInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::LookupName, ::RemoteMachineInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRemoteMachineInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::LookupName* /*request*/, ::RemoteMachineInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::LookupName, ::RemoteMachineAvatar>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::LookupName* request) { return this->GetRemoteMachineAvatar(context, request); }));
    }
    ~WithCallbackMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::grpc::ServerWriter< ::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::RemoteMachineAvatar>* GetRemoteMachineAvatar(
      ::grpc::CallbackServerContext* /*context*/, const ::LookupName* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::TransferOpRequest, ::VoidType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TransferOpRequest* request, ::VoidType* response) { return this->ProcessTransferOpRequest(context, request, response); }));}
    void SetMessageAllocatorFor_ProcessTransferOpRequest(
        ::grpc::MessageAllocator< ::TransferOpRequest, ::VoidType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TransferOpRequest, ::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::TransferOpRequest* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProcessTransferOpRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::TransferOpRequest* /*request*/, ::VoidType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::OpInfo, ::VoidType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::OpInfo* request, ::VoidType* response) { return this->PauseTransferOp(context, request, response); }));}
    void SetMessageAllocatorFor_PauseTransferOp(
        ::grpc::MessageAllocator< ::OpInfo, ::VoidType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::OpInfo, ::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseTransferOp(
      ::grpc::CallbackServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartTransfer() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::OpInfo, ::FileChunk>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::OpInfo* request) { return this->StartTransfer(context, request); }));
    }
    ~WithCallbackMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::grpc::ServerWriter< ::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::FileChunk>* StartTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::OpInfo* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::OpInfo, ::VoidType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::OpInfo* request, ::VoidType* response) { return this->CancelTransferOpRequest(context, request, response); }));}
    void SetMessageAllocatorFor_CancelTransferOpRequest(
        ::grpc::MessageAllocator< ::OpInfo, ::VoidType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::OpInfo, ::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelTransferOpRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopTransfer() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::StopInfo, ::VoidType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::StopInfo* request, ::VoidType* response) { return this->StopTransfer(context, request, response); }));}
    void SetMessageAllocatorFor_StopTransfer(
        ::grpc::MessageAllocator< ::StopInfo, ::VoidType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::StopInfo, ::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::StopInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::StopInfo* /*request*/, ::VoidType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Ping() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::LookupName, ::VoidType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::LookupName* request, ::VoidType* response) { return this->Ping(context, request, response); }));}
    void SetMessageAllocatorFor_Ping(
        ::grpc::MessageAllocator< ::LookupName, ::VoidType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::LookupName, ::VoidType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::LookupName* /*request*/, ::VoidType* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_CheckDuplexConnection<WithCallbackMethod_WaitingForDuplex<WithCallbackMethod_GetRemoteMachineInfo<WithCallbackMethod_GetRemoteMachineAvatar<WithCallbackMethod_ProcessTransferOpRequest<WithCallbackMethod_PauseTransferOp<WithCallbackMethod_StartTransfer<WithCallbackMethod_CancelTransferOpRequest<WithCallbackMethod_StopTransfer<WithCallbackMethod_Ping<Service > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::grpc::ServerWriter< ::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::TransferOpRequest* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartTransfer() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::grpc::ServerWriter< ::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopTransfer() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::StopInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ping() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckDuplexConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitingForDuplex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRemoteMachineInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::grpc::ServerWriter< ::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRemoteMachineAvatar(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::TransferOpRequest* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProcessTransferOpRequest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseTransferOp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartTransfer() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::grpc::ServerWriter< ::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTransfer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelTransferOpRequest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopTransfer() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::StopInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopTransfer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ping() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckDuplexConnection(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckDuplexConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WaitingForDuplex(context, request, response); }));
    }
    ~WithRawCallbackMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitingForDuplex(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRemoteMachineInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRemoteMachineInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetRemoteMachineAvatar(context, request); }));
    }
    ~WithRawCallbackMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::grpc::ServerWriter< ::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetRemoteMachineAvatar(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ProcessTransferOpRequest(context, request, response); }));
    }
    ~WithRawCallbackMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::TransferOpRequest* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProcessTransferOpRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseTransferOp(context, request, response); }));
    }
    ~WithRawCallbackMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseTransferOp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartTransfer() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StartTransfer(context, request); }));
    }
    ~WithRawCallbackMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::grpc::ServerWriter< ::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StartTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelTransferOpRequest(context, request, response); }));
    }
    ~WithRawCallbackMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelTransferOpRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopTransfer() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopTransfer(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::StopInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Ping() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ping(context, request, response); }));
    }
    ~WithRawCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckDuplexConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckDuplexConnection() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LookupName, ::HaveDuplex>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::LookupName, ::HaveDuplex>* streamer) {
                       return this->StreamedCheckDuplexConnection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckDuplexConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckDuplexConnection(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckDuplexConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LookupName,::HaveDuplex>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitingForDuplex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WaitingForDuplex() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LookupName, ::HaveDuplex>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::LookupName, ::HaveDuplex>* streamer) {
                       return this->StreamedWaitingForDuplex(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WaitingForDuplex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitingForDuplex(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::HaveDuplex* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitingForDuplex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LookupName,::HaveDuplex>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRemoteMachineInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRemoteMachineInfo() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LookupName, ::RemoteMachineInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::LookupName, ::RemoteMachineInfo>* streamer) {
                       return this->StreamedGetRemoteMachineInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRemoteMachineInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRemoteMachineInfo(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::RemoteMachineInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRemoteMachineInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LookupName,::RemoteMachineInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProcessTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ProcessTransferOpRequest() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TransferOpRequest, ::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TransferOpRequest, ::VoidType>* streamer) {
                       return this->StreamedProcessTransferOpRequest(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ProcessTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ProcessTransferOpRequest(::grpc::ServerContext* /*context*/, const ::TransferOpRequest* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProcessTransferOpRequest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TransferOpRequest,::VoidType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseTransferOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseTransferOp() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::OpInfo, ::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::OpInfo, ::VoidType>* streamer) {
                       return this->StreamedPauseTransferOp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseTransferOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseTransferOp(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseTransferOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::OpInfo,::VoidType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelTransferOpRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelTransferOpRequest() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::OpInfo, ::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::OpInfo, ::VoidType>* streamer) {
                       return this->StreamedCancelTransferOpRequest(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelTransferOpRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelTransferOpRequest(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelTransferOpRequest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::OpInfo,::VoidType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopTransfer() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::StopInfo, ::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::StopInfo, ::VoidType>* streamer) {
                       return this->StreamedStopTransfer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopTransfer(::grpc::ServerContext* /*context*/, const ::StopInfo* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopTransfer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::StopInfo,::VoidType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ping() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LookupName, ::VoidType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::LookupName, ::VoidType>* streamer) {
                       return this->StreamedPing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::VoidType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LookupName,::VoidType>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CheckDuplexConnection<WithStreamedUnaryMethod_WaitingForDuplex<WithStreamedUnaryMethod_GetRemoteMachineInfo<WithStreamedUnaryMethod_ProcessTransferOpRequest<WithStreamedUnaryMethod_PauseTransferOp<WithStreamedUnaryMethod_CancelTransferOpRequest<WithStreamedUnaryMethod_StopTransfer<WithStreamedUnaryMethod_Ping<Service > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetRemoteMachineAvatar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetRemoteMachineAvatar() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::LookupName, ::RemoteMachineAvatar>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::LookupName, ::RemoteMachineAvatar>* streamer) {
                       return this->StreamedGetRemoteMachineAvatar(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetRemoteMachineAvatar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRemoteMachineAvatar(::grpc::ServerContext* /*context*/, const ::LookupName* /*request*/, ::grpc::ServerWriter< ::RemoteMachineAvatar>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetRemoteMachineAvatar(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::LookupName,::RemoteMachineAvatar>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StartTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StartTransfer() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::OpInfo, ::FileChunk>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::OpInfo, ::FileChunk>* streamer) {
                       return this->StreamedStartTransfer(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StartTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartTransfer(::grpc::ServerContext* /*context*/, const ::OpInfo* /*request*/, ::grpc::ServerWriter< ::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStartTransfer(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::OpInfo,::FileChunk>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetRemoteMachineAvatar<WithSplitStreamingMethod_StartTransfer<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_CheckDuplexConnection<WithStreamedUnaryMethod_WaitingForDuplex<WithStreamedUnaryMethod_GetRemoteMachineInfo<WithSplitStreamingMethod_GetRemoteMachineAvatar<WithStreamedUnaryMethod_ProcessTransferOpRequest<WithStreamedUnaryMethod_PauseTransferOp<WithSplitStreamingMethod_StartTransfer<WithStreamedUnaryMethod_CancelTransferOpRequest<WithStreamedUnaryMethod_StopTransfer<WithStreamedUnaryMethod_Ping<Service > > > > > > > > > > StreamedService;
};

class WarpRegistration final {
 public:
  static constexpr char const* service_full_name() {
    return "WarpRegistration";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status RequestCertificate(::grpc::ClientContext* context, const ::RegRequest& request, ::RegResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RegResponse>> AsyncRequestCertificate(::grpc::ClientContext* context, const ::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RegResponse>>(AsyncRequestCertificateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RegResponse>> PrepareAsyncRequestCertificate(::grpc::ClientContext* context, const ::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RegResponse>>(PrepareAsyncRequestCertificateRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void RequestCertificate(::grpc::ClientContext* context, const ::RegRequest* request, ::RegResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestCertificate(::grpc::ClientContext* context, const ::RegRequest* request, ::RegResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RegResponse>* AsyncRequestCertificateRaw(::grpc::ClientContext* context, const ::RegRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RegResponse>* PrepareAsyncRequestCertificateRaw(::grpc::ClientContext* context, const ::RegRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status RequestCertificate(::grpc::ClientContext* context, const ::RegRequest& request, ::RegResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RegResponse>> AsyncRequestCertificate(::grpc::ClientContext* context, const ::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RegResponse>>(AsyncRequestCertificateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RegResponse>> PrepareAsyncRequestCertificate(::grpc::ClientContext* context, const ::RegRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RegResponse>>(PrepareAsyncRequestCertificateRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void RequestCertificate(::grpc::ClientContext* context, const ::RegRequest* request, ::RegResponse* response, std::function<void(::grpc::Status)>) override;
      void RequestCertificate(::grpc::ClientContext* context, const ::RegRequest* request, ::RegResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::RegResponse>* AsyncRequestCertificateRaw(::grpc::ClientContext* context, const ::RegRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RegResponse>* PrepareAsyncRequestCertificateRaw(::grpc::ClientContext* context, const ::RegRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_RequestCertificate_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status RequestCertificate(::grpc::ServerContext* context, const ::RegRequest* request, ::RegResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::RegRequest* /*request*/, ::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestCertificate(::grpc::ServerContext* context, ::RegRequest* request, ::grpc::ServerAsyncResponseWriter< ::RegResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_RequestCertificate<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::RegRequest, ::RegResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RegRequest* request, ::RegResponse* response) { return this->RequestCertificate(context, request, response); }));}
    void SetMessageAllocatorFor_RequestCertificate(
        ::grpc::MessageAllocator< ::RegRequest, ::RegResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RegRequest, ::RegResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::RegRequest* /*request*/, ::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestCertificate(
      ::grpc::CallbackServerContext* /*context*/, const ::RegRequest* /*request*/, ::RegResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_RequestCertificate<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::RegRequest* /*request*/, ::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::RegRequest* /*request*/, ::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestCertificate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RequestCertificate(context, request, response); }));
    }
    ~WithRawCallbackMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::RegRequest* /*request*/, ::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestCertificate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestCertificate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RequestCertificate() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RegRequest, ::RegResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RegRequest, ::RegResponse>* streamer) {
                       return this->StreamedRequestCertificate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RequestCertificate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestCertificate(::grpc::ServerContext* /*context*/, const ::RegRequest* /*request*/, ::RegResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestCertificate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RegRequest,::RegResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_RequestCertificate<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_RequestCertificate<Service > StreamedService;
};


#endif  // GRPC_warp_2eproto__INCLUDED
